# Hash Table
## Описание проекта
Данный проект можно разбить на 2 части:
1) исследование различных хеш-функций и выбор наиболее оптимальной, то есть имеющей минимальный load factor и минимальную дисперсию
2) оптимизация работы функции поиска по ключу в хеш-таблице
## Что такое хеш-таблица?
Хеш-таблица - это структура данных, хранящая пары элементов (ключ, значение). Выполняет три основные операции:
добавляет ключ, удаляет ключ, выполняет поиск по ключу. Значение для ключа равно числу, которое возвращает хеш-функция (обычно значение зависит от ключа). Хранятся ключи в связном списке: хеш-таблица хранит массив связных списков, индекс списка в массиве равен значению хеша для ключа. Таким образом, если хеш-функция возвращает уникальные значения для разных ключей, поиск элемента (ключа) в хеш-таблице имеет асимптотическую сложность О(1).

<img src= "https://github.com/vvit19/HashTable/blob/master/data/hashtwiki.png" width="500px"/>

В рамках нашей задачи ключами являются слова из произведения У.Шекспира "Гамлет".

## 1 часть: исследование хеш-функций
### Хеш-функция возвращает 0

Очевидно, что данная хеш-функция является ужасной, но в образовательных целях исследована и она.

<img src= "https://github.com/vvit19/HashTable/blob/master/data/hash0.png" width="500px"/>

> Load factor = 4407

> Dispersion = 63056,63

### Хеш-функция возвращает ASCII-code первого символа слова

<img src= "https://github.com/vvit19/HashTable/blob/master/data/hash0ascii.png" width="500px"/>

> Load factor = 169,5

> Dispersion = 3389,68

Дяже при небольшом размере хеш-таблицы получен высокий load factor, то есть большое число коллизий. Поэтому данная хеш-функция неэффективна.

### Хеш-функция возвращает длину слова

<img src= "https://github.com/vvit19/HashTable/blob/master/data/strlen.png" width="500px"/>

> Load factor = 348,14

> Dispersion = 10271,12

Load factor и дисперсия даже больше, чем для предыдущей хеш-функции. Данная хеш-функция также неэффективна.

### Хеш-функция возвращает сумму ASCII-кодов символов слова

<img src= "https://github.com/vvit19/HashTable/blob/master/data/ascii300.png" width="500px"/>

> Load factor = 16,03

> Dispersion = 99,93

У этой хеш-фукнции довольно низкие значения load factor и дисперсии. Может показаться, что она оптимальна, но посмотрите на гистограмму при большем размере хеш-таблицы:

<img src= "https://github.com/vvit19/HashTable/blob/master/data/ascii2000.png" width="500px"/>

> Load factor = 5,56

> Dispersion = 21,73

Видно, что в общем случае она не такая эффективная из-за ограниченности суммы ASCII-кодов, многие значения хеш-функции просто не достигаются, при еще больших размерах хеш-таблицы будут увеличиваться дисперсия и load factor. Однако она очевидно эффективнее предложенных ранее хеш-функций.

### ROR hash

Принцип работы данной хеш-функции: создается цикл длины, равной длине ключа. В цикле выполняется битовый сдвиг значения хеша на 1 вправо. Затем делается XOR с текущим символом слова (ключа). Полученное значение присваивается хешу, цикл выполняется далее.

<details>

<summary>ROR hash implementation</summary>

~~~ C++

uint32_t HashRor (const char* word, size_t len)
{
    uint32_t hash_value = 0;
    for (size_t i = 0; i < len; i++) hash_value = Ror (hash_value, 1) ^ (uint32_t) word[i];

    return hash_value;
}

static inline uint32_t Ror (uint32_t num, int shift)
{
    return (num >> shift) | (num << ((int) sizeof (num) * 8 - shift));
}

~~~

</details>

<img src= "https://github.com/vvit19/HashTable/blob/master/data/ror.png" width="500px"/>

> Load factor = 3,12

> Dispersion = 6,79

Показатели load factor и дисперсии самые оптимальные среди всех перечисленных выше функций.

Интересный факт: ассемблерный листинг ```Ror```:

<img src= "https://github.com/vvit19/HashTable/blob/master/profilerdata/ror.png" width="500px"/>

С включенной оптимизацией -О3 компилятор распознал функцию ```Ror``` и подставил ассемблерный стандартный ```ror```.

### ROL hash

Алгоритм данной хеш-функции аналогичен алгоритму ROR hash, только здесь выполняется сдвиг влево, а не вправо.

<img src= "https://github.com/vvit19/HashTable/blob/master/data/rol.png" width="500px"/>

> Load factor = 2,93

> Dispersion = 4,17

Показатели еще лучше, чем у ROR hash, пока это - самая эффективная хеш-функция.

### Crc32 Hash

Принцип работы этой хеш-функции можно узнать здесь: [CRC32_wikipedia](https://ru.wikipedia.org/wiki/%D0%A6%D0%B8%D0%BA%D0%BB%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D0%B8%D0%B7%D0%B1%D1%8B%D1%82%D0%BE%D1%87%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%B4).

<details>

<summary>Crc32 hash implementation</summary>

~~~ C++
uint32_t HashCrc32(const char* word, size_t len)
{
    uint32_t crc = 0;

    crc = 0xFFFFFFFF;

    for (size_t i = 0; i < len; i++)
    {
        crc = crc32_tab[(crc ^ word[i]) & 0xFF] ^ (crc >> 8);
    }

    return crc ^ 0xFFFFFFFF;
}
~~~

</details>

<img src= "https://github.com/vvit19/HashTable/blob/master/data/crc32.png" width="500px"/>

> Load factor = 2,69

> Dispersion = 2,50

Получены впечатляющие показатели load factor и дисперсии (самые низкие по всем рассматриваемым хеш-функциям).

### Вывод

Идеальный показатель load factor вычисляется как отношение числа ключей к размеру хеш-таблицы (в таком случае имеем дисперсию, равную 0). Так, он равен: $\frac{4407}{2003} = 2,20$. Благодаря Crc32 Hash получен наиболее близкий к этому значению результат (load factor = 2,69), а также минимальная дисперсия (dispersion = 2,50). При рассмотрении вопросов оптимизации будем использовать именно эту хеш-функцию.

## 2 часть: оптимизации функции поиска элемента в хеш-таблице

### Параметры системы

### Параметры системы и методика тестирования

- **OS**: Ubuntu 22.04.4 LTS
- **CPU**: Intel(R) Core(TM) i7-10510U CPU @ 1.80GHz
- **Compiler**: gcc 11.4.0
- **Compiler flags**: -g -O3 -mavx2

Тестирование заключалось в поиске в хеш-таблице слов из текста. Для расчета времени исполнения функции поиска использован профилировщик ```callgrind```.

### Использование памяти в программе

В программе хранится много указателей на строки (для заполнения хеш-таблицы и для тестирования). Будем хранить слова из текстов в памяти подряд, выделяя под них по 32 байта (поскольку обычно длина слов явно меньше 32 букв) и выравнивая их. Это выгодно по 2 причинам. 1 причина: для архитектуры x86-64 кеш-линии имеют размер 64 байта. Таким образом, если размещать по 2 32-байтовых выровненных слова подряд, процессор c большей вероятностью переместит их в кеш. 2 причина заключается в том, что такое хранение поможет в дальнейшем применять для сравнения строк YMM регистры процессора, используя AVX инструкции.

Отчет ```callgrind``` об использовании кеша:

<img src= "https://github.com/vvit19/HashTable/blob/master/profilerdata/cache.png" width="500px"/>

Показания промахов кеша очень низкие, что показывает, что в программе эффективно используется память.

### Базовая версия

Отчет профилировщика:

<img src= "https://github.com/vvit19/HashTable/blob/master/profilerdata/base.png" width="500px"/>

| Оптимизации | Время <br> CPU cycles    | Абсолютное ускорение | Относительное ускорение |
| :---------: | :------: | :----------: | :------------: |
| Baseline    | 3 015 051 475 | 1 | 1 |

Самыми затратными по времени фукнциями, которые вызывает функция поиска, являются ```HashCrc32``` (36 %) и ```strcmp``` (30 %). Их я и буду оптимизировать.

Примечание: функция ```FindWord``` состоит только из присваиваний, цикла и прочих накладных расходов, что и обеспечивает такое время работы. Поэтому я считаю ее оптимизацию ненужной (ускорение будет очень низким, при этом ухудшится читаемость кода, и функция ```CheckRepeat``` может перестать быть ```inline```, если писать ее в отдельном ассемблерном файле).

Отчет о работе ```FindWord```:

<img src= "https://github.com/vvit19/HashTable/blob/master/profilerdata/findword0.png" width="500px"/>

### HashCrc32 optimization

Вообще говоря, хеш-функция ```CRC32``` была подобрана неслучайно. Дело в том, что существует ассемблерная функция, которая считает этот хеш. Можно использовать AVX инструкции:

~~~ C++
uint32_t IntrinsicHashCrc32 (const char* word, size_t len)
{
	uint32_t hash = 0xEDB88320;

	for (size_t i = 0; i < len; i++)
		hash = _mm_crc32_u8 (hash, word[i]);

	return hash;
}

~~~

Отчет профилировщика:

<img src= "https://github.com/vvit19/HashTable/blob/master/profilerdata/hashopt.png" width="500px"/>

| Оптимизации | Время <br> CPU cycles   | Абсолютное ускорение | Относительное ускорение |
| :---------: | :------: | :----------: | :------------: |
| Baseline    | 3 015 051 475 | 1 | 1 |
| Intrinsic Hash | 2 575 987 573 | 1,17 | 1,17 |

Непосредственно функция расчета хеша ускорилась на 40 %, и теперь большую часть времени работы функции поиска занимает ```strcmp```. Дальше будем ускорять ее.

### Strcmp optimization

Ускорим ```strcmp```, написав ее на ассемблере. Здесь как раз и пригодится, что под слова в памяти выделено по 32 байта.

~~~ asm
global AsmStrcmp

section .text
AsmStrcmp:
        vmovdqu ymm1, yword [rdi]
        vpcmpeqb ymm0, ymm1, yword [rsi]
        vpmovmskb rax, ymm0
        ret

~~~


Отчет профилировщика:

<img src= "https://github.com/vvit19/HashTable/blob/master/profilerdata/asmcmp.png" width="500px"/>

| Оптимизации | Время <br> CPU cycles   | Абсолютное ускорение | Относительное ускорение |
| :---------: | :------: | :----------: | :------------: |
| Baseline    | 3 015 051 475 | 1 | 1 |
| Intrinsic Hash | 2 575 987 573 | 1,17 | 1,17 |
| Assembly strcmp | 1 785 268 509 | 1,69 | 1,44 |

Получено значительное ускорение программы. Однако сейчас на вызов ```AsmStrcmp``` тратится значительное число времени. Это можно исправить, сделав ассемблерную ```strcmp``` инлайновой. В этом помогут ассемблерные вставки.

### Inline assembly strcmp optimization

~~~ C++

static inline int InlineAsmStrcmp (const char str1[WORD_LEN], const char str2[WORD_LEN])
{
    int res = 0;

    asm (".intel_syntax noprefix\n"
         "vmovdqa ymm1, YMMWORD PTR [%1]\n"
         "vpcmpeqb ymm0, ymm1, YMMWORD PTR [%2]\n"
         "vpmovmskb %0, ymm0\n"
         ".att_syntax prefix\n"
         : "=r" (res) : "r" (str1), "r" (str2) : "ymm0", "ymm1", "cc");

    return res;
}

~~~

Отчет профилировщика:

<img src= "https://github.com/vvit19/HashTable/blob/master/profilerdata/inlinecmp.png" width="500px"/>

| Оптимизации | Время <br> CPU cycles   | Абсолютное ускорение | Относительное ускорение |
| :---------: | :------: | :----------: | :------------: |
| Baseline    | 3 015 051 475 | 1 | 1 |
| Intrinsic Hash | 2 575 987 573 | 1,17 | 1,17 |
| Assembly strcmp | 1 785 268 509 | 1,69 | 1,44 |
| Inline asm strcmp | 1 680 728 056 | 1,79 | 1,06 |

Есть прирост во времени относительно предыдущей оптимизации. Действительно, поскольку обычно ```strcmp``` вызывается в циклах, инлайн подстановка гораздо выгоднее, чем обычный вызов.

### Вывод

Благодаря профилировщику можно искать узкие места в программе, которые можно оптимизировать. Таким образом, точечными низкоуровневыми оптимизациями программа была ускорена в 1,79 раз. Это показывает, что использование только компиляторных оптимизаций недостаточно.

Бонус: DED_coeff = $\frac{\text{ускорение программы}}{количество  ассемблерных  строк} * 1000 = \frac{1790}{12} = 141,17$

## Список литературы и ресурсов

- Randal Bryant, David O'Hallaron - Computer Systems: A Programmer's Perspective 3rd Edition
- Valgrind - https://valgrind.org/
- Compiler Explorer - https://godbolt.org/
- Mirror of Intel® Intrinsics Guide - https://www.laruence.com/sse
- Wikipedia: [HashTable](https://en.wikipedia.org/wiki/Hash_table), [Crc32](https://ru.wikipedia.org/wiki/%D0%A6%D0%B8%D0%BA%D0%BB%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D0%B8%D0%B7%D0%B1%D1%8B%D1%82%D0%BE%D1%87%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%B4)
